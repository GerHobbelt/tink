/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {SecurityException} from '../../../exception/security_exception';
import * as keyManager from '../../../internal/key_manager';
import {PbHpkePublicKey, PbKeyData, PbMessage} from '../../../internal/proto';
import * as util from '../../../internal/util';
import {HybridEncrypt} from '../hybrid_encrypt';

import {HpkeEncrypt} from './hpke_encrypt';
import * as hpkeValidators from './hpke_validators';

/**
 * This class corresponds to the 'HpkePrivateKeyFactory', but it does not
 * support key generation. The 'HpkePrivateKeyFactor'y' should be use to
 * generate new HPKE key pairs.
 * @final
 */
class HpkePublicKeyFactory implements keyManager.KeyFactory {
  newKey(keyFormat: PbMessage|Uint8Array): never {
    throw new SecurityException(
        'This operation is not supported for public keys. ' +
        'Use HpkePrivateKeyManager to generate new keys.');
  }

  newKeyData(serializedKeyFormat: Uint8Array): never {
    throw new SecurityException(
        'This operation is not supported for public keys. ' +
        'Use HpkePrivateKeyManager to generate new keys.');
  }
}

/**
 * Key manager that produces new instances of {@link HpkeEncrypt} primitives.
 * @final
 */
export class HpkePublicKeyManager implements
    keyManager.KeyManager<HybridEncrypt> {
  static KEY_TYPE = 'type.googleapis.com/google.crypto.tink.HpkePublicKey';
  private static readonly SUPPORTED_PRIMITIVE = HybridEncrypt;
  static VERSION = 0;
  keyFactory = new HpkePublicKeyFactory();
  /**
   * Constructs an instance of the 'HybridEncrypt' primitive for a given HPKE
   * public key.
   */
  async getPrimitive(
      primitiveType: util.Constructor<HybridEncrypt>,
      key: PbKeyData|PbMessage) {
    if (primitiveType !== this.getPrimitiveType()) {
      throw new SecurityException(
          'Requested primitive type which is not ' +
          'supported by this key manager.');
    }
    const keyProto: PbHpkePublicKey = HpkePublicKeyManager.getKeyProto(key);
    hpkeValidators.validatePublicKey(keyProto, this.getVersion());
    return HpkeEncrypt.createHpkeEncrypt(keyProto);
  }
  /** Returns true if this KeyManager supports 'HpkePublicKey' key type. */
  doesSupport(keyType: string) {
    return keyType === this.getKeyType();
  }
  /** Returns the URL which identifies the keys managed by this KeyManager. */
  getKeyType() {
    return HpkePublicKeyManager.KEY_TYPE;
  }
  /**
   * Returns the type of primitive which can be generated by this KeyManager,
   * i.e. 'HybridEncrypt'
   */
  getPrimitiveType() {
    return HpkePublicKeyManager.SUPPORTED_PRIMITIVE;
  }

  getVersion() {
    return HpkePublicKeyManager.VERSION;
  }

  getKeyFactory() {
    return this.keyFactory;
  }

  private static getKeyProto(keyMaterial: PbKeyData|
                             PbMessage): PbHpkePublicKey {
    if (keyMaterial instanceof PbKeyData) {
      return HpkePublicKeyManager.getKeyProtoFromKeyData(keyMaterial);
    }
    if (keyMaterial instanceof PbHpkePublicKey) {
      return keyMaterial;
    }
    throw new SecurityException(
        'Key type is not supported. This key manager supports ' +
        HpkePublicKeyManager.KEY_TYPE + '.');
  }

  private static getKeyProtoFromKeyData(keyData: PbKeyData): PbHpkePublicKey {
    if (keyData.getTypeUrl() !== HpkePublicKeyManager.KEY_TYPE) {
      throw new SecurityException(
          'Key type ' + keyData.getTypeUrl() + ' is not supported. This key ' +
          'manager supports ' + HpkePublicKeyManager.KEY_TYPE + '.');
    }
    let key: PbHpkePublicKey;
    try {
      key = PbHpkePublicKey.deserializeBinary(keyData.getValue());
    } catch (e) {
      throw new SecurityException(
          'Input cannot be parsed as ' + HpkePublicKeyManager.KEY_TYPE +
          ' key-proto.');
    }
    /**
     * Throws the same generic error to avoid discrepancies between different
     * versions.
     */
    if (!key.getParams() || !key.getPublicKey()) {
      throw new SecurityException(
          'Input cannot be parsed as ' + HpkePublicKeyManager.KEY_TYPE +
          ' key-proto.');
    }
    return key;
  }
}
